# beer_order.customer_id バックフィル戦略（メモ）

目的: 既存の注文（beer_order）レコードに対して、新設した `customer_id` を安全に埋める。初期は NULL 許容で運用し、後続で NOT NULL 制約化を検討する。

## 前提
- V3 マイグレーションで `beer_order.customer_id` は NULL 可として追加済み。
- アプリ側では新規作成フローで Customer を紐付け、以後の注文は `customer_id` が設定される想定。

## バックフィル方針
1. 対応パターンの定義
   - 顧客参照 `customerRef` とメール/電話番号などの外部キーに準ずる情報が整っている場合、Customer テーブルから該当行を検索し、`customer_id` を設定。
   - 一意に決まらない場合はバックフィル対象外（NULL 維持）。
2. 実行手段
   - オンライン移行の場合はアプリのメンテナンスタスク（バッチ）として実装し、楽観的ロックで少量ずつ更新。
   - 代替として、DB スクリプト（SQL/PL）で一括更新。ただし曖昧マッチや重複時の扱いに注意。
3. 監査/検証
   - バックフィル結果の件数と失敗件数をログ/レポート化。
   - バックフィル後も NULL が残る前提で、アプリは NULL を許容したまま動作（後続の NOT NULL 化は NULL 行が 0 になってから）。
4. 後続マイグレーション
   - `beer_order.customer_id` の NOT NULL 付与（外部キーは保持）。
   - 必要に応じてインデックス最適化（`ix_beer_order_customer` の再作成/統計更新）。

## ロールバック戦略
- バックフィル処理は idempotent に設計（再実行可）。
- 想定外の更新が発生した場合はトランザクション単位でロールバック。長時間ロックを避けるため小さなバッチ単位で実施。

## 受け入れ条件
- バックフィル済み件数 > 0（データがある環境）であること。
- バックフィル後の新規注文は必ず `customer_id` が設定されることを E2E テストで確認。
- NOT NULL 化マイグレーションの適用前に、`SELECT COUNT(*) FROM beer_order WHERE customer_id IS NULL` が 0 を満たす。